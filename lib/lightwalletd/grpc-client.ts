// lib/lightwalletd/grpc-client.ts
//
// Node-only gRPC client for lightwalletd (CompactTxStreamer).
// This module is used exclusively from Next.js route handlers (runtime: "nodejs").
//
// IMPORTANT:
// - This client only handles PUBLIC blockchain data.
// - It must NEVER receive viewing keys, decrypted notes, or any sensitive payload.

import path from "node:path";
import * as grpc from "@grpc/grpc-js";
import * as protoLoader from "@grpc/proto-loader";
import type { LightwalletdEndpoint } from "./endpoints";

// Minimal public shapes that our API routes will expose as JSON.
export interface GrpcLightdInfo {
  chainName: string;
  blockHeight: number;
  vendor?: string;
}

export interface GrpcCompactBlock {
  height: number;
  hashHex?: string;
}

export interface GrpcTransaction {
  rawHex: string;
}

// Internal type for the CompactTxStreamer client generated by grpc-js.
type CompactTxStreamerClient = grpc.Client & {
  getLightdInfo(
    request: Record<string, never>,
    callback: (err: grpc.ServiceError | null, res?: any) => void
  ): void;

  getBlockRange(
    request: any
  ): grpc.ClientReadableStream<any>;

  getTransaction(
    request: any,
    callback: (err: grpc.ServiceError | null, res?: any) => void
  ): void;
};

// Lazy-loaded gRPC package / constructor.
let compactTxStreamerCtor: grpc.ServiceClientConstructor | null = null;

/**
 * Load the CompactTxStreamer service definition from grpc/service.proto.
 * This is done lazily so that the module can be imported without immediately
 * touching the filesystem (useful for tests / build steps).
 */
function getCompactTxStreamerCtor(): grpc.ServiceClientConstructor {
  if (compactTxStreamerCtor) {
    return compactTxStreamerCtor;
  }

  const grpcDir = path.join(process.cwd(), "grpc");
  const serviceProtoPath = path.join(grpcDir, "service.proto");

  const packageDefinition = protoLoader.loadSync(serviceProtoPath, {
    keepCase: true,
    longs: Number,
    enums: String,
    defaults: true,
    oneofs: true,
    includeDirs: [grpcDir],
  });

  const loaded = grpc.loadPackageDefinition(packageDefinition) as any;

  const svc =
    loaded?.cash?.z?.wallet?.sdk?.rpc
      ?.CompactTxStreamer as grpc.ServiceClientConstructor | undefined;

  if (!svc) {
    throw new Error(
      "Failed to load CompactTxStreamer service from grpc/service.proto"
    );
  }

  compactTxStreamerCtor = svc;
  return svc;
}

/**
 * Derive gRPC target address (host:port) and TLS usage from a LightwalletdEndpoint.
 *
 * Example:
 *  - endpoint.url = "https://zec.rocks:443"
 *    â†’ target = "zec.rocks:443", TLS enabled.
 */
function getGrpcTarget(endpoint: LightwalletdEndpoint): {
  address: string;
  useTls: boolean;
} {
  const url = new URL(endpoint.url);

  const port =
    url.port ||
    (url.protocol === "https:" ? "443" : url.protocol === "http:" ? "80" : "");

  if (!port) {
    throw new Error(`Missing port in lightwalletd endpoint URL: ${endpoint.url}`);
  }

  const address = `${url.hostname}:${port}`;
  const useTls = url.protocol === "https:";

  return { address, useTls };
}

/**
 * Create a CompactTxStreamer gRPC client for a given endpoint.
 * Caller is responsible for calling client.close() once finished.
 */
function createGrpcClient(endpoint: LightwalletdEndpoint): CompactTxStreamerClient {
  const ctor = getCompactTxStreamerCtor();
  const { address, useTls } = getGrpcTarget(endpoint);

  const credentials = useTls
    ? grpc.credentials.createSsl() // Uses system root CAs
    : grpc.credentials.createInsecure();

  const client = new ctor(address, credentials) as unknown as CompactTxStreamerClient;
  return client;
}

/**
 * Call GetLightdInfo on the given endpoint and map the result to GrpcLightdInfo.
 */
export async function grpcGetLightdInfo(
  endpoint: LightwalletdEndpoint
): Promise<GrpcLightdInfo> {
  const client = createGrpcClient(endpoint);

  try {
    const res: any = await new Promise((resolve, reject) => {
      client.getLightdInfo({}, (err, response) => {
        if (err) return reject(err);
        resolve(response);
      });
    });

    return {
      chainName: res.chain_name ?? res.chainName ?? "unknown",
      blockHeight: Number(res.block_height ?? res.blockHeight ?? 0),
      vendor: typeof res.vendor === "string" ? res.vendor : undefined,
    };
  } finally {
    client.close();
  }
}

/**
 * Call GetBlockRange on the given endpoint and collect the streamed CompactBlock messages.
 */
export async function grpcGetCompactBlockRange(
  endpoint: LightwalletdEndpoint,
  startHeight: number,
  endHeight: number
): Promise<GrpcCompactBlock[]> {
  const client = createGrpcClient(endpoint);

  try {
    const blocks: GrpcCompactBlock[] = [];

    await new Promise<void>((resolve, reject) => {
      const request = {
        start: { height: startHeight },
        end: { height: endHeight },
      };

      const call = client.getBlockRange(request);

      call.on("data", (block: any) => {
        const height = Number(block.height ?? 0);
        const hashBytes: Buffer | Uint8Array | undefined = block.hash;

        let hashHex: string | undefined;
        if (hashBytes && (hashBytes as any).length) {
          const buf =
            hashBytes instanceof Buffer
              ? hashBytes
              : Buffer.from(hashBytes as Uint8Array);
          hashHex = buf.toString("hex");
        }

        blocks.push({
          height,
          hashHex,
        });
      });

      call.on("error", (err: grpc.ServiceError) => {
        reject(err);
      });

      call.on("end", () => {
        resolve();
      });
    });

    return blocks;
  } finally {
    client.close();
  }
}

/**
 * Call GetTransaction on the given endpoint, returning raw tx bytes encoded as hex.
 *
 * Returns null when the transaction is not found (NOT_FOUND).
 */
export async function grpcGetTransaction(
  endpoint: LightwalletdEndpoint,
  txidBytes: Uint8Array
): Promise<GrpcTransaction | null> {
  const client = createGrpcClient(endpoint);

  try {
    const res: any = await new Promise((resolve, reject) => {
      const request = {
        hash: Buffer.from(txidBytes),
      };

      client.getTransaction(request, (err, response) => {
        if (err) {
          // Map NOT_FOUND to null instead of throwing.
          if (err.code === grpc.status.NOT_FOUND) {
            return resolve(null);
          }
          return reject(err);
        }
        resolve(response);
      });
    });

    if (!res) {
      return null;
    }

    const data: Buffer | Uint8Array | undefined = res.data;
    if (!data || !(data as any).length) {
      return null;
    }

    const buf =
      data instanceof Buffer ? data : Buffer.from(data as Uint8Array);

    return {
      rawHex: buf.toString("hex"),
    };
  } finally {
    client.close();
  }
}
